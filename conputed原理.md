1. 初始化阶段
   当创建 Vue 实例时，Vue 会遍历 data 对象中的每一个属性，并使用 Object.defineProperty 将这些属性转换为响应式属性。这意味着每个属性的 getter 和 setter 方法会被定义，使 Vue 可以追踪这些属性的读取和修改操作。

响应式系统的核心：Vue 的响应式原理基于 Object.defineProperty，它为每个 data 属性设置了 getter 和 setter。当属性被访问时，getter 会被触发，Vue 会记录哪些依赖使用了这个属性；当属性值发生变化时，setter 会被触发，通知相关依赖进行更新。

- Watcher 对象：在响应式系统中，Vue 为每一个依赖于响应式数据的属性（包括 DOM 绑定、计算属性等）创建一个 Watcher 对象。Watcher 负责订阅数据的变化，并在数据改变时通知相关的更新操作

2. 创建 Computed（计算属性）
   当你定义一个计算属性（computed）时，Vue 会为每个计算属性注册一个独立的 Watcher。这项工作由 initComputed 函数完成，它为每个计算属性创建一个 Watcher，并将这个 Watcher 与该计算属性的 getter 方法绑定。

依赖追踪：在初始化时，Vue 会执行一次计算属性的 getter，并在执行过程中追踪所有用到的 data 属性（即依赖）。这些依赖被记录在计算属性的 Watcher 中，因此当这些依赖发生变化时，Vue 会知道需要重新计算计算属性的值。 3. 更新 Computed 值
当 data 中的某个属性发生变化时，对应的 Watcher 会收到通知。对于计算属性的 Watcher 而言，这意味着当依赖的数据改变时，计算属性的 getter 方法会被重新调用，以计算出新的值。

懒执行：Vue 中的计算属性是惰性求值的。计算属性的 getter 只有在依赖的 data 属性变化时才会重新执行。而如果计算属性的值没有被视图层访问，则即使依赖的数据改变了，计算属性也不会立即重新计算。 4. 缓存 Computed 值
为了提升性能，Vue 会对计算属性的值进行缓存。缓存的机制可以避免在没有必要的情况下反复计算值。

缓存机制：在计算属性第一次被访问时，Vue 会执行该属性的 getter，并将结果缓存起来。在下一次访问时，Vue 不会立即重新执行 getter，而是先检查计算属性的依赖数据是否发生了变化。如果依赖数据没有变化，Vue 直接返回缓存的值；如果依赖发生了变化，Vue 会清空缓存并重新计算计算属性的值。
性能优化：通过这种机制，Vue 可以避免不必要的重复计算，从而提升性能，尤其是在复杂计算或大量依赖的场景下，缓存机制可以显著减少性能消耗

3. 视图渲染
   在 Vue 的更新过程中，当组件首次渲染或数据发生变化时，Vue 会创建一个 渲染 Watcher。这个 Watcher 负责管理和跟踪组件的模板中所用的所有响应式属性，包括计算属性。

#### 计算属性懒执行

**这意味着计算属性的值不会立即重新计算。只有当计算属性被视图或其他代码访问时，Vue 才会重新调用 getter 来计算新的值**
