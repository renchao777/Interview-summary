# diff 算法

**diff 算法是一个平级比较的过程 父亲和父亲比对， 儿子和儿子比对**

Vue 是一个双向数据绑定的框架，当 data 中的数据发生变化时，会响应式地渲染页面的相关 DOM 元素
为了提升渲染性能，Vue 使用了虚拟 DOM 技术。在这种实现中，页面的所有 DOM 都被抽象成虚拟 DOM
如果某些数据发生变化，Vue 会通过 diff 算法比较新旧虚拟 DOM 节点，计算出最小的变更路径，从而以最小代价更新实际的 DOM 元素

## Diff 算法核心逻辑

(1)父节点对比

1. 如果两个元素的标签或 key 不相同，则直接替换整个节点
2. 如果标签并且 key 相同，继续比对属性和子节点
3. 更新属性，用新的虚拟节点的属性和老的对比，去更新节点
4. 比较孩子
   新旧节点都有子节点时，递归调用 diff 算法
   新节点没有子节点时，删除旧节点的子节点
   旧节点没有子节点时，直接插入新节点的子节点

(2)子节点对比

**diff 算法采用 双端比较策略，即在两端依次对比新旧虚拟 DOM 节点。这种方法通过减少遍历次数来提高效率，尤其针对 push、pop、shift、unshift、reverse、sort 等数组操作做了优化，该算法会分别从头和尾对比新旧虚拟节点，直到一方的头指针超过尾指针，停止循环。下面是详细的子节点对比过程**

1. 新前 vs 旧前
   比较新的虚拟节点列表的第一个节点和旧的虚拟节点列表的第一个节点。如果相同，移动指针，继续向后对比下一个。直到遇到不同的节点，随后进行插入或删除处理

2. 新后 vs 旧后
   比较新的虚拟节点列表的最后一个节点和旧的虚拟节点列表的最后一个节点。如果相同，移动指针，继续向前对比上一个。直到遇到不同的节点，随后进行插入或删除处理

3. 新前 vs 旧后
   比较新的虚拟节点列表的第一个节点与旧的虚拟节点列表的最后一个节点，如果相同移动指针，不同将旧后的DOM 节点插入到旧前节点的前面，并继续比较

   old = ['A','B','C']
   new = ['C','A','B']

4. 新后 vs 旧前
   比较新的虚拟节点列表的最后一个节点与旧的虚拟节点列表的第一个节点，如果相同移动指针，不同将旧前的 DOM 节点插入到旧后节点的后面，并继续比较

   old = ['A','B','C']
   new = ['B','C','A']

5. 乱序比对
   如果以上四种情况都不匹配，则进入乱序比对。此时，Vue 会基于旧的虚拟节点列表创建一个映射关系，然后根据新的虚拟节点去寻找对应的旧节点。如果找到，则移动节点；如果找不到，则添加新节点。最后，多余的旧节点将被删除

vue3 最长递增子序列LIS
   Vue 3 diff 乱序节点时，先把旧节点在新列表中的索引标记出来，删除不在新列表的旧节点，保留可以对应的新旧节点，然后用 LIS 找出顺序正确的节点不动，其余节点移动或插入，从而最小化 DOM 更新，提高性能
## Vue 2 Diff 算法特点

性能优化：Vue 2 的 diff 算法适合处理中小规模的节点更新。双端比较策略能够有效地减少遍历次数。
节点复用：为了避免不必要的 DOM 重绘，Vue 尽量复用相同的节点，因此在动态列表中，给每个节点分配唯一的 key 非常重要

### 关于 key 的使用

在动态列表中尽量避免用索引作为 key，例如 ['a','b','c','d'] 变成 ['d','a','b','c'] 时，索引 key 会让框架把每个位置当作新节点，导致整个列表重新渲染。使用稳定唯一的 id 可保证节点正确复用

