### keep-alive

**keep-alive 是 Vue 的一个内置组件，主要用于缓存组件实例,从而避免不必要的销毁和重建**

#### 主要用途

1. keep-alive 在路由中使用
2. 在 component:is 中使用(缓存)

#### 工作原理

keep-alive 的原理是默认缓存加载过的组件对应的实例 内部采用了 LRU 算法下次组件切换加载的时候 此时会找到对应缓存的节点来进行初始化，但是会采用上次缓存$e1 来触发更新和销毁会触发 actived 和 deactived

keep-alive 采用了 LRU（Least Recently Used，最近最少使用）策略来管理缓存。被激活的组件实例会被保留在内存中，方便下一次切换时快速恢复。

2. 初次渲染
   组件创建：当使用 keep-alive 包裹一个组件时，初次渲染时，Vue 会创建这个组件的实例。这个过程包括调用组件的生命周期钩子（如 beforeCreate、created），并关联一个虚拟节点（VNode）表示该组件的结构。

虚拟 DOM 渲染：组件的 render 函数会生成一个虚拟节点树（VNode），表示组件的视图。此时，Vue 会调用 patch 函数将这个 VNode 渲染为真实的 DOM 元素，并插入到页面中。

3. 组件切换与缓存
   切换组件：当用户切换到其他组件时，keep-alive 会将当前组件的实例缓存，而不是销毁它。此时，deactivated 钩子会被调用，表示组件已被停用，但其状态和 DOM 节点仍然保留。

缓存组件实例：keep-alive 采用了 LRU（Least Recently Used，最近最少使用）策略来管理缓存。被激活的组件实例会被保留在内存中，方便下一次切换时快速恢复。

4. 组件重新激活
   激活组件：当用户切换回之前的组件时，keep-alive 会从缓存中恢复该组件的实例。此时，activated 钩子被调用，表示组件被重新激活。

复用组件实例：Vue 会直接复用之前的组件实例，而不会重新创建。组件的状态（如 data、computed 等）保持不变，这样用户在切换时可以无缝体验。

5. 视图更新
   即使组件处于缓存状态，组件的视图仍然可以根据数据变化进行更新。以下是更新的过程：

数据变化：如果组件的 props 或 data 发生变化，Vue 会重新计算组件的虚拟节点（VNode）。即使组件实例是缓存的，数据的变化依然会触发视图更新。

虚拟 DOM 更新：在数据变化时，Vue 会生成一个新的 VNode，表示更新后的组件结构。此时，组件的 render 函数被调用，生成新的虚拟节点。

patch 函数：接下来，Vue 使用 patch 函数对比新旧 VNode，通过 diff 算法找出变化的部分。patch 会根据变化更新真实的 DOM，仅更新需要改变的部分，确保 DOM 操作最小化。
