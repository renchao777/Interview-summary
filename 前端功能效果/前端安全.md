# 前端安全

## xss 跨站脚本攻击

**攻击者在网页中注入恶意脚本，用户浏览时执行，可能窃取 Cookie 或表单数据，篡改页面内容，甚至发起伪造操作，如发帖、修改资料**

三种类型：

1. 反射型 XSS: 攻击者通过 URL 或表单传入恶意脚本，用户访问页面时脚本立即执行

动态渲染用户输入

2. 存储型 XSS：恶意脚本存储在服务器（如数据库），访问页面时执行

富文本编辑器内容

3. DOM-based XSS：恶意脚本通过修改页面 DOM 执行，通常发生在 v-html 或动态 innerHTML 渲染用户内容时

实际应用场景: 

1. 文章富文本

用户或管理员发布的文章可能包含格式化文本和图片,渲染时使用 v-html，先用编辑器或 DOMPurify 做安全过滤，禁止 <script>、<iframe> 等危险标签

意识到问题：直接渲染用户 HTML 不安全，可能被注入 <script>、<iframe> 或事件属性。

编辑器端过滤（可选）：在 WangEditor 中限制允许的标签和属性，只保留必要的格式和图片，过滤危险标签
```js
import E from 'wangeditor'

const editor = new E('#editor')

// 配置菜单，只允许必要功能
editor.config.menus = [
  'bold', 'italic', 'underline', 'head', 'link', 'list', 'quote', 'image'
]

// 粘贴过滤，移除危险标签
editor.config.pasteTextHandle = function (pasteStr) {
  return pasteStr.replace(/<(script|iframe|style)[\s\S]*?>[\s\S]*?<\/\1>/gi, '')
}

editor.create()

```

渲染端二次清理（必须）：用 DOMPurify 做白名单过滤，即使用户绕过编辑器也能防止注入攻击。

```js
import DOMPurify from 'dompurify'

export default {
  props: {
    content: String  // 后端返回的文章 HTML
  },
  computed: {
    safeContent() {
      return DOMPurify.sanitize(this.content, {
        ALLOWED_TAGS: [
          'b','i','em','strong','a','p','ul','ol','li','br','img','blockquote','h1','h2','h3'
        ],
        ALLOWED_ATTR: ['href','src','alt','title','target']
      })
    }
  }
}
```

安全渲染：处理后的 HTML 通过 v-html 渲染，既安全又保留格式和图片

2. 无感知 Token 刷新机制：用户登录后，长 Token（Refresh Token）存 Cookie，并设置 HttpOnly（前端不可访问）和 SameSite=Lax/Strict（防止跨站请求携带）。同源请求自动带 Cookie，同时前端在请求头携带随机生成的 CSRF Token，防止 XSS 或 CSRF 攻击窃取或滥用 Token

## CSRF 跨站请求伪造

**攻击者利用用户已登录状态，通过浏览器自动带 Cookie，伪造请求让网站以为是用户本人操作**

1. 用户在网站 A 登录，浏览器保存了该网站的 Cookie

2. 攻击者诱导用户点击恶意链接或访问攻击页面

3. 在用户未登出的情况下，攻击者的请求会自动携带 Cookie 发送给网站 A

4. 网站 A 无法分辨请求是用户真实发出的还是攻击伪造的

### 常见攻击方式

在现代 Vue SPA 中，传统 CSRF 攻击方式主要是

GET 请求伪造：通过 <img>、<a>、<script> 等方式自动请求

POST 请求伪造：通过隐藏表单 + JavaScript 自动提交

实际运用场景:

1. 用户资料修改, 密码修改

Vue + Axios 调用接口修改用户资料
```js
axios.post('/api/user/update', {
  nickname: '哥',
  email: 'me@example.com'
})
```
如果后端只依赖 Cookie 做认证，攻击者在恶意网站放一个表单：

```js
<form action="https://yourapp.com/api/user/update" method="POST">
  <input type="hidden" name="nickname" value="黑客" />
  <input type="hidden" name="email" value="hacker@evil.com" />
  <input type="submit" />
</form>
```

1. 双 Cookie 校验 核心是防 CSRF

HttpOnly Cookie 防止 XSS 窃取敏感凭证

前端可读 Cookie 只是携带 CSRF Token，不存敏感信息


2. 敏感操作二次验证 → 即使 Token 被窃取，也无法直接操作