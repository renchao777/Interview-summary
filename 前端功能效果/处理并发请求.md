# 处理并发请求

应用场景: 需要批量请求但又必须限制并发数的场景，比如后台首页加载多个接口

控制并发限制: 因为浏览器和后端都有限制，如果一次性发太多请求，容易导致阻塞或超时。限制并发能让请求更稳定，也能保证页面加载更顺畅
HTTP/1.1 浏览器为了避免单个网站占满所有 TCP 连接，通常限制 同一域名下最大 6 个并发请求

实现原理: 

维护一个队列和一个计数器，同时最多只跑 concurrency 个请求。如果满了，新请求就先排队。等有请求完成了，计数器减一，再从队列里取下一个继续执行，直到所有请求都跑完

```js
/**
 * 并发请求队列（每次仅在并发数允许的情况下，添加请求到队列）
 * @param {Array} reqs 请求 URL 数组
 * @param {number} concurrency 最大并发数
 */
export const handleQueue = (reqs = [], concurrency = 6) => {
  const queue = [];  // 请求池
  let activeRequests = 0;  // 当前进行中的请求数

  // 处理队列中的请求
  const dequeue = () => {
    // 当请求池中还有请求且当前进行中的请求数未达到最大并发数时，继续发送请求
    while (queue.length && activeRequests < concurrency) {
      const request = queue.shift();  // 从队列中取出一个请求（先进先出）
      activeRequests++;  // 增加正在进行中的请求数
      request().finally(() => {
        activeRequests--;  // 请求完成后，减少正在进行中的请求数
        dequeue();  // 请求完成后，继续执行队列中的请求
      });
    }
  };

  // 将请求 URL 转换为请求函数并入队
  const enqueueRequest = async (requestFn) => {
    // 等待直到有空余的并发槽位
    while (activeRequests >= concurrency) {
      await new Promise(resolve => setTimeout(resolve, 100));  // 每 100ms 检查一次
    }
    queue.push(requestFn);  // 加入请求
    dequeue();  // 启动队列
  };

  reqs.forEach(url => {
    const requestFn = () => axios.get(url).catch(error => console.error(error));
    enqueueRequest(requestFn);  // 请求加入队列
  });

  dequeue();  // 启动请求队列
}

import { handleQueue } from './queue';

const urls = [
  '/api/user/info',
  '/api/system/statistics',
  '/api/tasks/todo',
  '/api/orders/summary',
  '/api/sales/chart',
  '/api/notifications'
];

// 限制最大并发数为 3
handleQueue(urls, 3);
```