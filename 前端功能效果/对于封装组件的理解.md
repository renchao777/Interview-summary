# 对于封装组件的理解

## vue 组件封装的意义

**组件封装的目标提高代码的，复用性，可维护性，以及扩展性**

## Vue 组件的三大特性

1. Props（属性传递）

   可以设置默认值和类型验证，保证组件即用性数据的正确性（类型验证 required 属性进行必要的类型验证）

2. 事件（事件传递）

   子组件通过 $emit 触发自定义事件，与父组件进行通信
   遵循命名规范，避免与内置事件冲突，通常自定义事件的名称可以使用 on- 前缀的事件

3. 插槽（内容分发）

   空插槽：预留空 slot 方便插入自定义内容，例如弹窗组件的内容插槽或布局组件的具名插槽（如 header、footer）
   具名插槽：具名插槽用于多区域内容插入
   作用域插槽：可将组件内部数据传递给插槽内容，增强灵活性

## 组件封装原则

1. 单一职责原则

   组件应只专注于完成一个任务或功能，不要让一个组件承担多种职责
   复杂的功能可以通过拆分为更小的子组件来实现，从而保持组件的简洁和易维护

2. 开放封闭原则

   组件设计应对扩展开放，减少修改，以保持原有功能的稳定性

   我们可以使用高阶组件来实现进行组件扩展

## 高阶组件（Higher-Order Component，HOC）

**是一种设计模式，主要用于增强组件的功能，HOC 本质上是一个函数，它接受一个组件作为参数，并返回一个新的组件，从而实现逻辑复用和功能扩展**

1.函数以 with 开头：常用的约定是以 with 开头，例如 withAuthorization、withLogging，这样可以直观地表明这是一个增强功能的组件。

描述性命名：可以根据高阶组件的功能给它起一个描述性的名字，比如 withDataFetching 表示用于数据获取的高阶组件

```js
定义高阶组件：根据具体功能创建 HOC，可以命名为任何符合功能描述的名称
function withAuthorization(WrappedComponent) {
  return {
    created() {
      // 认证逻辑
    },
    template: `<WrappedComponent />`,
    components: {
      WrappedComponent,
    },
  };
}
使用高阶组件：在需要增强的组件中使用 HOC
const AuthorizedComponent = withAuthorization(MyComponent);
```

3. 避免过度封装

   可以说明过度封装可能导致的代码复杂性和维护难度

4. 样式隔离

   Scoped CSS 和 CSS Modules：实现样式局部隔离，避免样式冲突

   BEM 命名规范：遵循 BEM 规范，减少样式干扰

5. 动态创建和实例化组件-通过某个方法执行渲染组件

   可以创建类似 window.alert() 的提示组件

   组件构造器：通过 Vue.extend 创建组件构造函数并动态实例化组件，然后将实例进行$mount() 手动挂载和 $destroy() 清理组件
   调用方式贴近传统 JavaScript 函数风格

6. 其他注意事项

   $nextTick：在数据变化后使用 $nextTick 确保 DOM 更新完成再执行操作，解决数据与 DOM 渲染的同步问题

7. 性能优化

   使用 keep-alive 缓存组件实例，减少不必要的渲染，并可以异步加载组件以提高初始加载性能

### 项目中的 pupop 组件

1. 组件架构：

这是一个可复用的弹出框组件
通过 Vue.extend 创建构造器，实现动态实例化，使得组件在不同场景下可重复使用

2. 动态内容加载：

动态加载子组件，确保弹出框的内容可以根据不同需求进行切换

3. 状态管理：

组件内部使用多个状态属性（如 myShow, isShow, btnShow 等）来控制显示和功能，确保弹出框的行为灵活

4. 生命周期处理：

在 mounted 钩子中计算内容区域的高度，确保用户在不同屏幕尺寸下也能获得良好体验

5. 用户交互：

设计了确认和取消按钮，用户可以通过这些按钮进行操作，并提供了相应的回调函数（confirm 和 cancel）供外部使用

6. CSS 样式：

使用了 Scoped CSS 和 SCSS，确保样式的局部性和可维护性，避免全局样式冲突
