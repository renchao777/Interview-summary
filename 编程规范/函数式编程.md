# 函数式编程

**函数式编程一种编程范式，强调使用纯函数来构建程序，函数可以作为参数传递，也可以作为返回值返回**

优点: 通过纯函数和不可变状态提升代码得可维护性与可读性, 没有副作用,测试和调试更简单,天然支持并发和并行,不会有共享可变状态,函数可组合提升代码的复用性和表达力

## 主要特点

1. 纯函数：函数的输出仅依赖于输入参数，不产生副作用（即不修改外部状态），这使得函数可预测，容易测试和调试

```js
function multiply(x, y) {
  return x * y; // 输出只依赖于输入，不产生副作用
}

console.log(multiply(2, 3)); // 6
console.log(multiply(2, 3)); // 每次都返回相同的结果
```

```js
let externalVariable = 10;

function pureFunction(x) {
  return x + externalVariable; // 依赖于外部状态，导致不是纯函数
}

console.log(pureFunction(5)); // 15
externalVariable = 20;
console.log(pureFunction(5)); // 25（结果依赖于外部变量，副作用）
```

2. 不可变性：数据一旦创建就不能修改。这种方式可以帮助避免副作用，并且使得状态管理更可预测，减少数据共享引发的问题

```js
const arr = [1, 2, 3];

// 不可变地添加元素，返回一个新数组
const newArr = [...arr, 4]; // arr 仍然是 [1, 2, 3]
console.log(newArr); // [1, 2, 3, 4]
```

3. 高级函数：可以接收函数作为参数，或者返回一个新函数，比如我们常用的防抖函数就是这样

```js
function debounce(fn, delay) {
  let timer = null;
  return function (...args) {
    if (timer) clearTimeout(timer); // 清除上一次的计时器
    timer = setTimeout(() => {
      fn.apply(this, args); // 触发函数
    }, delay);
  };
}

// 使用示例：在用户输入停止 500ms 后才发送请求
const handleInput = debounce(() => {
  console.log("Input event");
}, 500);

```

4. 函数组合：可以将多个小的函数组合成一个复杂的函数，这种组合方式有助于重用和简化代码
在处理数据时，通常会有多个步骤的转换和处理，compose 可以将这些步骤组合成一个函数链条，使代码更加清晰

```js
const mul3 = x => x * 3;
const div2 = x => x / 2;
const add1 = x => x + 1; // 定义 add1 函数

const compose = function compose(...funcs) {
    let len = funcs.length;
    if (len === 0) return x => x;
    if (len === 1) return funcs[0];
     return function operate(x) {
        // 使用 reduceRight 从右到左应用函数
        return funcs.reduceRight((x, func) => func(x), x);
    };
    };
};

const operate = compose(div2, mul3, add1);
console.log(operate(0)); // 输出 3
console.log(operate(2)); // 输出 6

```

5. 递归：函数式编程常使用递归来解决问题，而不是传统的循环结构

```js
// 计算阶乘的递归函数
function factorial(n) {
    if (n === 0) {
        return 1;
    }
    return n \* factorial(n - 1);
}

console.log(factorial(5)); // 120

```
