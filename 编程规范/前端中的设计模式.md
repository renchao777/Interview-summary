# 前端中的设计模式

定义: 设计模式是一种可复用的解决方案,用于软件设计中常见的问题,js中常用的两大原则 单一职责原则和开放闭合原则

1. 单一职责原则: 一个方法一个类只负责一个职责,各个职责程序的改动不影响其他程序

组件化思想正是单一职责原则的良好实践，每个组件都聚焦于单一功能，从而提升了系统的可维护性与可复用性

2. 开放闭合原则：模块和函数应该对扩展开放，对修改关闭

优点: 设计模式的优点本质上来源它的核心思想--封装变化, 将逻辑中的便与不变分离,确保变化的部分灵活,不变的部分稳定

- 提升代码的可维护性 - 降低耦合度,提高复用性 - 让系统更灵活,可扩展


## 开发中用的最多的几种

1. 构造器模式: 在 js 中，通过构造函数（或 class）来创建并初始化对象，这种方式就称为构造器模式

在 Vue 2 中，Vue 是一个大的类，每个组件都是该类的实例。创建组件的过程就是构造器模式的应用，实际开发中使用 Vue.extend 创建组件也是这种模式的体现

2. 工厂模式: 通过工厂函数批量创建并返回对象

axios.create 就是工厂模式的应用，每次调用都会返回一个全新的 Axios 实例

3. 单例模式: 保证一个类有且只有一个实例,避免重复创建对象

单例模式在前端主要用于需要全局共享的对象，保证状态统一，避免重复创建，提升性能和维护性

Vuex Store

整个应用只有一个 Vuex store 实例，所有组件共享同一份状态，保证数据统一

路由对象（VueRouter）

整个应用只有一个 router 实例，避免重复创建路由对象

单例是通过 模块导出 + 全局唯一实例 实现的

```js
// 这是单例类
var Singleton = function(name) {
    this.name = name
}
// 暴露出一个静态方法，来获取单例
Singleton.getInstance = (function() {
    var instance = null;
    return function(name){
        // 第一次执行getInstance函数，因为变量instance是null，所以执行if里面的语句 
        // 第二次执行getInstance函数，因为变量instance是new Singleton( name )，所以执行不执行if里的语句
        if(!instance) {
            instance = new Singleton(name)
        }
        return instance
    }
})();

```

4. 装饰器模式: 在不修改原有对象的基础上，通过对对象进行包装或扩展，为对象动态增加功能

Vue 2 在重写数组的方法时就用到了装饰器模式，它在保留数组原有方法的同时，为数组增加了响应式（Observer），从而可以监听数据变化

实际开发中我们用的高阶组件就是装饰器模式

```js
function withLogger(WrappedComponent) {
  return {
    render(h) {
      console.log('渲染组件');
      return h(WrappedComponent);
    }
  }
}
```
自定义指令: 给原生 DOM 元素增加功能，不改变元素本身
```js
Vue.directive('focus', {
  inserted(el) {
    el.focus(); // 在原有 DOM 元素功能上增加聚焦行为
  }
})
```

5. 代理模式: 在某些情况下,我们不能直接操作原有对象，而是委托带理去进行,代理者会对请求预先进行处理或转给实际对象

js中的防抖函数就是用的带理模式,通过debounce高阶函数返回新函数来代理fn的执行从而控制fn执行频率

```js
function debounce(fn, time) {
    time = time || 200
    let timer
    return function(...arg) {
        clearTimeout(timer)
        timer = setTimeout(() =>{
            fn.apply(this, arg)
        })
    }
}
let newFn = debounce(fn, 50)
```
6. 观察者模式：当一个对象的状态发生变化时，所有依赖它的对象都会收到通知并自动更新

Vue 2 双向绑定就是观察者模式的应用：
Vue 2 在初始化时，会遍历 data 中的每个属性，并通过 Object.defineProperty 劫持它们

访问属性时，getter 会收集依赖（Watcher）

修改属性时，setter 会派发更新

这样，当数据变化时，依赖的组件会自动刷新视图，实现双向绑定

7. 策略模式：不同的输入不同的策略，有需求变更时，只需要增加或者修改内部策略就可以

常用的场景时用来代替多个 if else 代码